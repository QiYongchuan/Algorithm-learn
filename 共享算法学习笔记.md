###  共享算法学习笔记

创建于2024.1.6



version 0.1



（一）

考试题目：

## ***\*复习2 综合复习\****

题量: 19 满分: 510.0 

作答时间:2023-12-29 12:45至01-07 12:00

窗体顶端

## ***\*一. 单选题（共2题）\****

### ***\*1.\**** ***\*(单选题)\**** ***\*【算法基础】冒泡排序算法的时间复杂度为（\**** ***\*A\**** ***\*）。\****

A

O（n^2）

B

O（n）

C

O（nlogn）

D

O（logn）

### ***\*2.\**** ***\*(单选题)\**** ***\*【算法基础】选择排序算法的时间复杂度为（  ）。\****

A

O（n^2）

B

O（n）

C

O（nlogn）

D

O（logn）

## ***\*二. 填空题（共3题）\****

### ***\*3.\**** ***\*(填空题)\**** ***\*【算法基础】 n^2+10n-1和14+5/5+1/n^2的渐进复杂度分别是O( )和O( )。\*******\*（a的n次方请表示为a^n的形式）\****

第1空

n^2

第2空

n^2

### ***\*4.\**** ***\*(填空题)\**** ***\*【算法基础】j结合NP完全理论，分析旅行售货员问题属于哪一类问题？\****

第1空

旅行售货员问题是一个NP-完全问题。这意味着找到最短路径的确切解决方案是非常困难的，尤其是在城市数量非常多的情况下。目前没有已知的算法可以在多项式时间内解决所有TSP实例，而且普遍认为这样的算法不存在（除非P=NP，这是一个未解决的问题）。 

### ***\*5.\**** ***\*(填空题)\**** ***\*【算法基础】讨论O(1)和O(2)的区别\****

第1空

O(1)和O(2)之间没有实质性的区别，因为它们都表示常数时间复杂度。

## ***\*三. 资料题（共14题）\****

### ***\*6.\**** ***\*(资料题)\****

【算法基础】如下2022美团笔试题，给出程序代码。

小团从某海鲜市场买到了一块3核CPU来应对他需要进行的高性能计算任务.小团-共有n个计算任务,編号分别为1到n.编号为的任务需要运行a秒.为了避免进程切换带来的开销,小团只能同时运行三个任务.也就是说他需要将这n个任务分成三组，并分别分配到cpu的三个核心上现在他想知道完成所有任务至少需要多少秒。

输入描述: 

  第一行有一个正整数n(1<=n<=100),代表计算任务的数量

  第二行有n个大小不超过1000的整数,空格隔开,分别代表编号为1到n的计算任务所需的运行时长

  输入的数据保证答案不超过10000

 

输出描述:

  输出一个整数,代表完成所有任务所需要的时间

 

第1空

 

### ***\*7.\**** ***\*(资料题)\****

【分治法】针对最大子段和问题：

（1）请利用分治法设计一个求解算法，针对输出一个序列，求出其最大子段和；给出算法设计方案和核心代码。

（2）利用master主定理分析该算法的算法复杂度；

（3）利用蛮力法设计最大子段和的求解思路，给出算法设计方案和核心代码、算法复杂度。

 答案：(1)设计思路：将字段一分为二，递归计算左侧字段的最大和，递归计算右侧字段的最大和以及计算中间向左侧和右侧的最大和结果比较上述三段的最大和，其中最大的为整个字段最终的最大和。 （2）代码：Int sum =0;Int MaxSum(int a[],left,right){If(left == right) a[left] >0?a[left]:0；  // 递归终止条件，当只剩下一个元素的时候，如果这个元素大于0，就是最大值；else{Int med = (left + right)/2;Int leftMaxsum = MaxSum(a,left,med);Int rightMaxsum = MaxSum(a,med+1,right); // 算中间部分的和=从中间向左的最大和（lefts)+从中间向右的最大和（rights) Int s1=0,lefts = 0; for(int i =med;med>=left;i--){Lefts+=a[i];If(lefts>s1) s1=lefts;} Int s2=0,rights=0;for(int i =med+1;med<right;i++){rights+=a[i];If(lrights>s1) s2=rights;}Int medSum = s1+s2;If(medSum <leftMaxsum ) sum = leftMaxsum ;If(medSum <rightMaxsum ) sum = rightMaxsum;Else{Sum = medSum;}}} ![img](file:///C:\Users\亓永传\AppData\Local\Temp\ksohtml6372\wps2.jpg) (3) 蛮力法：代码：![img](file:///C:\Users\亓永传\AppData\Local\Temp\ksohtml6372\wps3.jpg) ![img](file:///C:\Users\亓永传\AppData\Local\Temp\ksohtml6372\wps4.jpg)   

### ***\*8.\**** ***\*(资料题)\****

【分治法】设a[0:n-1]是已排好序的数组。请设计一个类二分搜索算法，使得当搜索元素x不在数组中时，返回小于x的最大元素位置i和大于x的最小元素位置j。当搜索元素在数组中时，i和j相同，均为x在数组中的位置。可选择算法流程图、伪代码或描述的形式进行算法说明。

 

第1空

 ![img](file:///C:\Users\亓永传\AppData\Local\Temp\ksohtml6372\wps5.jpg) ![img](file:///C:\Users\亓永传\AppData\Local\Temp\ksohtml6372\wps6.jpg) 只写上面思路就可以了 

### ***\*9.\**** ***\*(资料题)\****

【动态规划】对于序列X={C，D，B，A}、Y={A，B，C，B，A，D，B}，请分析两组序列是否具有公共子序列？并根据动态规划的思想，填写问题求解的二维最优子结构数组。（50分）

 

第1空

 ![image](https://github.com/Peppa2023/Algorithm-learn/assets/138690300/02c5807c-a85c-40f4-9f8a-7b145d36b35e)


### ***\*10.\**** ***\*(资料题)\****

【动态规划】问题描述：桌上有n张牌，编号为1到n，每张牌上有一个数字，第i张牌的数字为，现在小方和小明两个人玩游戏，轮流抽牌，每人一次只能抽一张牌，小明先抽。每次抽牌只能抽取最上面的牌或者最下面的牌，他们两个都是随机抽取，小明每次抽取上面的牌的概率为p，抽取下面的牌的概率为1-p。小方每次抽取上面的牌的概率为q，抽取下面的概率为1-q。最后他们的得分为所有牌上的数字之和，求小明的分数期望。

输入描述：第一行为三个数![img](file:///C:\Users\亓永传\AppData\Local\Temp\ksohtml6372\wps7.png)

，第二行为n个数，为每张牌上的分数。请利用回溯法进行分析分析与评价，求解小明的分数期望。

 

第1空

 

### ***\*11.\**** ***\*(资料题)\**** ***\*【贪心算法】\*******\*设某通信电文有a,b,c,d,e五个字符组成，他们在电文中出现的次数分别是14，7，10，3，21。给出他们的huffuman编码，画出对应的huffuman树，并解释其所用的算法类型。\****

第1空

 ![img](file:///C:\Users\亓永传\AppData\Local\Temp\ksohtml6372\wps8.jpg)![img](file:///C:\Users\亓永传\AppData\Local\Temp\ksohtml6372\wps9.jpg)![img](file:///C:\Users\亓永传\AppData\Local\Temp\ksohtml6372\wps10.jpg)

### **12.** ***\*(资料题)\**** ***\*【贪心算法】\*******\*思考Dijkstra算法求解单元最短路径的主要思路？试分析该问题为何具有最优子结构性质？\****

 

![img](file:///C:\Users\亓永传\AppData\Local\Temp\ksohtml6372\wps11.jpg) 

第1空

 

### ***\*13.\**** ***\*(资料题)\**** ***\*【贪心算法】\*******\*设C={0，1，…，n-1}是n个字符的集合。证明关于C的任何最优前缀码可以表示为长度为2n-1+nlogn位的编码序列。\****

![img](file:///C:\Users\亓永传\AppData\Local\Temp\ksohtml6372\wps12.jpg) 

 ![img](file:///C:\Users\亓永传\AppData\Local\Temp\ksohtml6372\wps13.jpg) 有点难啊

### ***\*14.\**** ***\*(资料题)\**** ***\*【回溯法】\*******\*设某一机器由n个部件组成，每种部件都可以从m个不同的供应商处购得。设Wij是从供应商j处购得的部件i的重量，Cij是相应的价格。试设计一个算法，给出总价格不超过C的最小重量机器设计。\****

第1空

 

### ***\*15.\**** ***\*(资料题)\**** ***\*【回溯法】设有n个立方体，每个立方体的每面都用红、黄、蓝、绿等n种颜色之一染色，要把这n个立方体叠成一个方型柱体，使得柱体的每个侧面均有n个不同的颜色。试设计一个回溯算法，计算出n个立方体的一种满足要求的叠置方案。\****

第1空

 

### ***\*16.\**** ***\*(资料题)\**** ***\*【分支限界】\*******\*以\*******\*0/1\*******\*背包为例，对比和比较回溯法和分支限界法求解问题的异同？分析节点扩展过程\****

第1空

 

### ***\*17.\**** ***\*(资料题)\**** ***\*【分支限界】\*******\*试设计\*******\*0/1\*******\*背包问题队列式分支限界法，并使算法在运行结束时输出最优解和最优值；同时分析算法复杂度。\****

第1空

 

### ***\*18.\**** ***\*(资料题)\****

【综合】迷宫问题

迷宫实验是取自心理学的一个古典实验。在该实验中，把一个老鼠从一个无顶大盒子的门放入，在盒中设置了许多墙，对行进方向进行多处阻挡。盒子仅有一个出口，在出口处放置一块奶酪，吸引老鼠在迷宫中寻找道路以达到出口。对同一只老鼠重复进行上述实验，一直到老鼠从入口到出口，而不走错一步。老鼠经多次试验终于得到它学习走迷宫的路线。迷宫由m行n列的二维数组设置，0表示无障碍，1表示有障碍。设入口为（1，1），出口为（m，n），每次只能从一个无障碍单元移到周围四个方向上任一无障碍单元。编程实现对任意设定的迷宫，求出一条从入口到出口的道路。

 

第1空

 

### ***\*19.\**** ***\*(资料题)\**** ***\*【综合】\*******\*针对\*******\*0/1\*******\*背包问题，分别给出蛮力法、动态规划算法、回溯法、分支限界法进行问题求解时的核心代码。\****

窗体底端


针对0/1背包问题，我可以提供四种方法的核心代码：蛮力法、动态规划算法、回溯法和分支限界法。这些方法在求解同一问题时有着不同的效率和复杂性。

0/1背包问题简介

0/1背包问题是一种经典的组合优化问题。给定一组物品，每个物品有一个重量和一个价值，确定应该将哪些物品放入背包中，以使得背包中的总价值最大，同时不超过背包的容量限制。

\1. 蛮力法

蛮力法遍历所有可能的物品组合，选出满足重量限制且价值最大的组合。

pythonCopy code

def brute_force_knapsack(values, weights, W):

  n = len(values)

  max_value = 0

 

  for i in range(2**n):

​    combo = [int(j) for j in format(i, f'0{n}b')]

​    weight = sum(combo[j] * weights[j] for j in range(n))

​    value = sum(combo[j] * values[j] for j in range(n))

 

​    if weight <= W and value > max_value:

​      max_value = value

 

  return max_value

\2. 动态规划算法

动态规划算法通过构建一个表格来逐步求解子问题，最终得到整个问题的解。

pythonCopy code

def dynamic_programming_knapsack(values, weights, W):

  n = len(values)

  dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]

 

  for i in range(1, n + 1):

​    for w in range(1, W + 1):

​      if weights[i-1] <= w:

​        dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1])

​      else:

​        dp[i][w] = dp[i-1][w]

 

  return dp[n][W]

\3. 回溯法

回溯法通过逐个考虑物品是否放入背包，回溯搜索所有可能的解。

pythonCopy code

def backtrack_knapsack(values, weights, W):

  n = len(values)

  max_value = [0]

 

  def backtrack(i, current_weight, current_value):

​    if i == n:

​      if current_value > max_value[0]:

​        max_value[0] = current_value

​      return

 

​    \# 不放当前物品

​    backtrack(i + 1, current_weight, current_value)

​    

​    \# 放当前物品（如果不超重）

​    if current_weight + weights[i] <= W:

​      backtrack(i + 1, current_weight + weights[i], current_value + values[i])

 

  backtrack(0, 0, 0)

  return max_value[0]

\4. 分支限界法

分支限界法类似于回溯法，但使用贪心策略来剪枝。

pythonCopy code

\# 这是一个简化的分支限界法示例def branch_and_bound_knapsack(values, weights, W):

  \# 需要实现节点类、优先队列等结构，以及相应的贪心策略和剪枝逻辑。

  \# 由于代码较长，这里不展开具体实现。

  pass

每种方法都有其适用场景和限制。蛮力法适用于小规模问题，动态规划适用于中等规模问题，回溯和分支限界法在某些情况下可以处理较大规模的问题，但也可能受限于时间和空间复杂度。

 
